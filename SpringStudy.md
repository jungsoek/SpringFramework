# 스프링 프레임워크 시작하기

스프링 웹 개발에 필요한 개발 환경을 구축한다.

개발 환경은 AWS EC2, Ubuntu OS, JDK, STS, Apache 서버, Tomcat 서버, MariaDB 순으로 설치한다.

## 개발 환경 구축

### JDK 설치

JDK는 오라클 홈페이지에 접속하면 무료로 내려받을 수 있다. JDK를 내려받을 수 있는 위치는 버전에 따라 다르기도 하고 URL 정보가 자주 변경되므로 구체적으로 기술하지는 않으나, 개발 환경의 버전을 알맞게 구성하는 것은 매우 중요한 일이다. 가급적 LTS 버전을 사용한다.

### STS 설치

### Apache, Tomcat 설치

### 데이터베이스 구축

## 실습 프로젝트 생성

### 프로젝트 생성

1. File - New - Spring Legacy Project - Project name 설정 - Templates : 'Spring MVC Project' 선택 후 Next 버튼

2. 최상위 패키지를 지정하는 화면

   패키지 경로에 최소 세 개 이상의 패키지가 지정되어야 Finish 버튼이 활성화되고 프로젝트를 생성할 수 있다. 

   입력란에 "com.springbook.biz"라고 입력하고 Finish 버튼 클릭

### 프로젝트 설정 변경

STS를 이용하여 'Spring MVC Project' 프로젝트를 생성하면 JRE 버전도 맞지 않고 서버 라이브러리도 등록되지 않으므로 이를 적절히 변경해야 한다. 이클립스의 프로젝트 탐색창에서 Board Web 프로젝트를 선택한 상태에서 마우스 오른쪽 버튼을 클릭하여 맨 아래에 [Properties]를 선택한다.

우선 왼쪽에서 [Project Facets]를 선택하고 Java 버전을 설치한 버전으로 수정한다.

그리고 오른쪽에 [Runtimes] 탭을 선택하고 'Apache Tomcat' 버전을 설치한 버전으로 체크한 후에 Apply, OK 버튼을 누른다.

설정을 마치고 다시 왼쪽에서 Java Build Path를 클릭하고 Libraries 탭을 클릭하여 경로를 확인했을 때 BuildPath는 이전에 선택한 3가지가 있어야 한다.

프로젝트가 생성되고 나면 스프링 기반의 웹 프로젝트 수행에 필요한 기본 설정 파일들과 소스들이 자동으로 생성된다. 이 파일들을 정리해야 앞으로 진행할 실습이 의미가 있다. 우선 src/main/resources 소스 폴더에 log4j.xml 파일을 제외한 나머지(패키지, 폴더, 파일들)는 모두 삭제한다.

그리고 src/main/webapp/WEB-INF 아래에 있는 spring과 views 폴더도 삭제한다.

# 프레임워크 개요

## 프레임 워크 개념

### 프레임워크의 등장 배경

프레임워크의 사전적 의미는 뼈대 혹은 틀로서 이 의미를 소프트웨어 관점에서 접근하면 아키텍처에 해당하는 골격 코드다.

### 프레임워크의 장점

잘 만들어진 프레임워크를 사용하면 애플리케이션에 대한 분석, 설계, 구현 모두에서 재사용성이 증가하는데, 이를 통해 다음과 같은 장점들을 얻을 수 있다.

### 자바 기반의 프레임워크

자바 기반의 프레임워크는 대부분 오픈소스 형태로 제공된다. 따라서 별도의 라이선스나 비용을 지불하지 않고 누구나 사용할 수 있으며, 기존의 프레임워크를 이용하여 자신만의 프레임워크를 구축할 수도 있다.

대표적인 자바 기반의 프레임워크로는 다음과 같은 것들이 있다.

## 스프링 프레임워크

### 스프링 탄생 배경

스프링 프레임워크는 로드 존슨이 2004년에 만든 오픈소스 프레임워크다. 스프링 프레임워크가 등장하기 이전에 자바 기반의 엔터프라이즈 애플리케이션은 대부분 EJB(Enterprise Java Beans)로 개발되었다. 그러나 EJB 기술은 EJB 컨테이너가 제공하는 많은 기능과 나름의 장점에도 불구하고 다음과 같은 여러 문제점 때문에 개발자들로부터 외면받을 수밖에 없었다.

### 스프링 프레임워크의 특징

스프링의 특징을 한 줄로 서술하면, "IoC와 AOP를 지원하는 경량의 컨테이너 프레임워크"로 표현할 수 있다.

## IoC(Inversion of Control) 컨테이너

스프링 프레임워크를 이해하는 데 가장 중요한 개념이 컨테이너이다. 컨테이너의 개념은 스프링에서 처음 사용된 것은 아니며, 기존의 서블릿이나 EJB 기술에서 이미 사용해왔다. 그리고 대부분의 컨테이너는 비슷한 구조와 동작 방식을 가지고 있으므로 서블릿 컨테이너를 통해 스프링 컨테이너의 동작 방식을 유추해볼 수 있다.

다음과 같이 간단한 서블릿 클래스를 만들었다고 가정한다.

### 결합도(Coupling)가 높은 프로그램

결합도란 하나의 클래스가 다른 클래스와 얼마나 많이 연결되어 있는지를 나타내는 표현이며, 결합도가 높은 프로그램은 유지보수가 어렵다. 이 결합도와 유지보수 관계를 이해하기 위해서 간단한 실습을 진행한다.

BoardWeb 프로젝트 src/main/java 소스 폴더에 SamsungTV 클래스를 작성한다.

### 다형성 이용하기

결합도를 낮추기 위해서 다양한 방법을 사용할 수 있겠지만, 가장 쉽게 생각할 수 있는 것이 객체지향 언어의 핵심 개념인 다형성(Polymorphism)을 이용하는 것이다. 앞에서 작성한 프로그램을 다형성을 이용하여 수정해본다. 다형성을 이용하려면 상속과 메소드 재정의(Overriding), 그리고 형변환이 필요하며, 자바 같은 객체지향 언어는 이를 문법으로 지원한다.

### 디자인 패턴 이용하기

결합도를 낮추기 위한 또 다른 방법으로 디자인 패턴을 이용하는 방법이 있다. 앞에서 살펴본 다형성을 이용하는 방법은 메소드를 호출할 때 인터페이스를 이용함으로써 좀 더 쉽게 TV를 교체할 수 있었다. 하지만 이 방법 역시 TV를 변경하고자 할 때, TV 클래스 객체를 생성하는 소스를 수정해야만 한다.

# 스프링 컨테이너 및 설정 파일

대부분 IoC 컨테이너는 각 컨테이너에서 관리할 객체들을 위한 별도의 설정 파일이 있다. Servlet 컨테이너는 web.xml 파일에, EJB 컨테이너는 ejb-jar.xml 파일에 해당 컨테이너가 생성하고 관리할 클래스들을 등록한다.

스프링 프레임워크도 다른 컨테이너와 마찬가지로 자신이 관리할 클래스들이 등록된 XML 설정 파일이 필요하다. 스프링 컨테이너가 사용할 XML 파일은 앞에서 설치한 STS를 이용하면 간단하게 만들 수 있다.

## 스프링 IoC 시작하기

### 스프링 설정 파일 생성

BoardWeb 프로젝트의 src/main/resources 소스 폴더를 선택하고 마우스 오른쪽 버튼을 클릭한다. 그리고 new - Other 메뉴를 클릭하면 아래와 같은 화면이 나온다. 여기서 'Spring' 폴더에 있는 'Spring Bean Configuration File'을 선택하고 Next를 클릭한다.

### 스프링 컨테이너 구동 및 테스트

스프링 설정 파일을 작성했으면 이제 TV 객체를 테스트하는 클라이언트를 만든다.

### 스프링 컨테이너의 종류

스프링에서는 BeanFactory와 이를 상속한 ApplicationContext 두 가지 유형의 컨테이너를 제공한다. 먼저 BeanFactory는 스프링 설정 파일에 등록된 bean 객체를 생성하고 관리하는 가장 기본적인 컨테이너 기능만 제공한다. 그리고 컨테이너가 구동될 때 bean 객체를 생성하는 것이 아니라, 클라이언트의 요청(Lookup)에 의해서만 bean 객체가 생성되는 지연 로딩(Lazy Loading) 방식을 사용한다. 따라서 일반적인 스프링 프로젝트에서 BeanFactory를 사용할 일은 전혀 없다.

## 스프링 XML 설정

### beans 루트 엘리먼트

스프링 컨테이너는 bean 저장소에 해당하는 XML 설정 파일을 참조하여 bean의 생명주기를 관리하고 여러 가지 서비스를 제공한다. 따라서 스프링 프로젝트 전체에서 가장 중요한 역할을 담당하며, 이 설정 파일을 정확하게 작성하고 관리하는 것이 무엇보다 중요하다.

### import 엘리먼트

스프링 설정 파일 하나에 우리가 만든 모든 클래스를 bean으로 등록하고 관리할 수도 있다. 하지만 스프링 기반의 애플리케이션은 단순한 bean 등록 외에도 트랜잭션 관리, 예외처리, 다국어 처리 등 복잡하고 다양한 설정이 필요하다.

### bean 엘리먼트

스프링 설정 파일에 클래스를 등록하려면 bean 엘리먼트를 사용한다. 이때 id와 class 속성을 사용하는데, id 속성은 생략할 수 있지만 class 속성은 필수이다. class 속성에 클래스를 등록할 때는 정확한 패키지 경로와 클래스 이름을 지정해야 한다. 따라서 될 수 있으면 STS의 자동 완성 기능을 이용하여 클래스를 정확하게 등록하기를 권장한다.

### bean 엘리먼트 속성

1. init-method 속성

   Servlet 컨테이너는 web.xml 파일에 등록된 Servlet 클래스의 객체를 생성할 때 디폴트 생성자만 인식한다. 따라서 생성자로 Servlet 객체의 멤버변수를 초기화할 수 없다. 그래서 서블릿은 init() 메소드를 재정의(Overriding)하여 멤버변수를 초기화한다.

2. destroy-method 속성

   init-method와 마찬가지로 bean 엘리먼트에서 destroy-method 속성을 이용하여 스프링 컨테이너가 객체를 삭제하기 직전에 호출될 임의의 메소드를 지정할 수 있다. 

3. lazy-init 속성

   ApplicationContext를 이용하여 컨테이너를 구동하면 컨테이너가 구동되는 시점에 스프링 설정 파일에 등록된 bean들을 생성하는 즉시 로딩(pre-loading) 방식으로 동작한다. 그런데 어떤 bean은 자주 사용되지도 않으면서 메모리를 많이 차지하여 시스템에 부담을 주는 경우도 있다.

   따라서 스프링에서는 컨테이너가 구동되는 시점이 아닌 해당 bean이 사용되는 시점에 객체를 생성하도록 init-lazy 속성을 제공한다. 특정 bean을 등록할 때, lazy-init="true"로 설정하면 스프링 컨테이너는 해당 bean을 미리 생성하지 않고 클라이언트가 요청하는 시점에 생성한다. 결국, 메모리 관리를 더 효율적으로 할 수 있게 된다.

4. 프로그램을 개발하다 보면 개발자도 모르는 사이에 수많은 객체가 생성된다. 그런데 이 중에는 하나만 생성돼도 상관없는 객체들이 있다. 예를 들어 우리가 사용 중인 SamsungTV 클래스에는 price 같은 변수가 있어서 생성되는 객체들이 다른 가격을 가지는 것도 아니므로 SamsungTV 클래스는 하나의 객체만 생성돼도 된다.

# 의존성 주입

## 의존성 관리

### 스프링의 의존성 관리 방법

스프링 프레임워크의 가장 중요한 특징은 객체의 생성과 의존관계를 컨테이너가 자동으로 관리한다는 점이다. 이것이 바로 스프링 IoC(제어의 역행)의 핵심 원리이기도 하다. 스프링은 IoC를 다음 두 가지 형태로 지원한다.

* Dependency Lookup
* Dependency Injection

![image-20250408151024867](./assets/image-20250408151024867.png)

이 중에서 컨테이너가 애플리케이션 운용에 필요한 객체를 생성하고 클라이언트는 컨테이너가 생성한 객체를 검색(Lookup)하여 사용하는 방식을 Dependency Lookup이라고 한다. Dependency Lookup은 우리가 지금까지 컨테이너를 사용해왔던 방법이다. 하지만 Dependency Lookup은 실제 애플리케이션 개발 과정에서는 사용하지 않으며, 대부분 Dependency Injection을 사용하여 개발한다.

### 의존성 관계

의존성(Dependency) 관계란 객체와 객체의 결합 관계이다. 즉, 하나의 객체에서 다른 객체의 변수나 메소드를 이용해야 한다면 이용하려는 객체에 대한 객체 생성과 생성된 객체의 레퍼런스 정보가 필요하다.

## 생성자 인젝션 이용하기

스프링 컨테이너는 XML 설정 파일에 등록된 클래스를 찾아서 객체 생성할 때 기본적으로 매개변수가 없는 기본(Default) 생성자를 호출한다. 하지만 컨테이너가 기본 생성자 말고 매개변수를 가지는 다른 생성자를 호출하도록 설정할 수 있는데, 이 기능을 이용하여 생성자 인젝션(Constructor Injection)을 처리한다. 생성자 인젝션을 사용하면 생성자의 매개변수로 의존관계에 있는 객체의 주소 정보를 전달할 수 있다.

생성자 인젝션을 테스트하기 위해서 SamsungTV 클래스에 생성자를 추가한다.

### 다중 변수 매핑

생성자 인젝션에서 초기화해야 할 멤버변수가 여러 개이면, 여러 개의 값을 한꺼번에 전달해야 한다. 이때는 다음처럼 생성자를 적절하게 추가하면 된다.

### 의존관계 변경

지금까지는 SamsungTV 객체가 SonySpeaker를 이용하여 동작했지만 유지보수 과정에서 다른 스피커로 교체하는 상황도 발생할 것이다. 의존성 주입은 이런 상황을 매우 효과적으로 처리해준다.

실습을 위해 모든 스피커의 최상위 부모로 사용할 Speaker 인터페이스를 추가한다.

## Setter 인젝션 이용하기

생성자 인젝션은 생성자를 이용하여 의존성을 처리한다. 하지만 Setter 인젝션은 이름에서 알 수 있듯이 Setter 메소드를 호출하여 의존성 주입을 처리하는 방법이다. 두 가지 방법 모두 멤버변수를 원하는 값으로 설정하는 것을 목적으로 하고 있고, 결과가 같으므로 둘 중 어떤 방법을 쓰든 상관없다. 다만 코딩 컨벤션에 따라 한 가지로 통일해서 사용하는데 대부분은 Setter 인젝션을 사용하며, Setter 메소드가 제공되지 않는 클래스에 대해서만 생성자 인젝션을 사용한다.

### Setter 인젝션 기본

Setter 인젝션을 테스트하기 위해 SamsungTV 클래스에 Setter 메소드를 추가한다.

### p 네임스페이스 사용하기

Setter 인젝션을 설정할 때, 'p 네임스페이스'를 이용하면 좀 더 효율적으로 의존성 주입을 처리할 수 있다. p 네임스페이스는 네임스페이스에 대한 별도의 schemaLocation이 없다. 따라서 네임스페이스만 적절히 선언하고 사용할 수 있다.

## 컬렉션(Collection) 객체 설정

프로그램을 개발하다 보면 배열이나 List 같은 컬렉션(Collection) 객체를 이용하여 데이터 집합을 사용해야 하는 경우가 있다. 이때 컬렉션  객체를 의존성 주입하면 되는데, 스프링에서는 이를 위하여 컬렉션 매핑과 관련된 엘리먼트를 지원한다.

| 컬렉션 유형          | 엘리먼트  |
| -------------------- | --------- |
| java.util.List, 배열 | `<list>`  |
| java.util.Set        | `<set>`   |
| java.util.Map        | `<map>`   |
| java.util.Properties | `<props>` |

여러 컬렉션 중에서 List만 대표로 테스트하고 나머지는 간단한 설정 사례만 확인한다.

### List 타입 매핑

배열 객체나 java.util.List 타입의 컬렉션 객체는 `<list>` 태그를 사용하여 설정한다. 먼저 List 컬렉션을 멤버변수로 가지는 CollectionBean 클래스를 다음과 같이 작성한다.

### Set 타입 매핑

중복 값을 허용하지 않는 집합 객체를 사용할 때는 java.util.Set이라는 컬렉션을 사용한다. 컬렉션 객체는 `set` 태그를 사용하여 설정할 수 있다.

### Map 타입 매핑

특정 Key로 데이터를 등록하고 사용할 때는 java.util.Map 컬렉션을 사용하며, `<map>` 태그를 사용하여 사용하여 설정할 수 있다.

### Properties 타입 매핑

key=value 형태의 데이터를 등록하고 사용할 때는 java.util.Properties라는 컬렉션을 사용하며, `props` 엘리먼트를 사용하여 설정한다.

# 어노테이션 기반 설정

## 어노테이션 설정 기초

대부분 프레임워크가 그렇듯이 스프링 프레임워크 역시 XML 설정이 매우 중요하다. 그만큼 XML 파일의 과도한 설정에 대한 부담도 크며, 이로 인해 프레임워크 사용을 꺼리기도 한다. 따라서 대부분 프레임워크는 어노테이션을 이용한 설정을 지원하고 있다.

### Context 네임스페이스 추가

어노테이션 설정을 추가하려면 다음과 같이 스프링 설정 파일의 루트 엘리먼트인 `beans`에 Context 관련 네임스페이스와 스키마 문서의 위치를 등록해야 한다. 이는 p 네임스페이스를 추가했을 때처럼 [Namespaces] 탭을 선택하고 'context' 항목만 체그하면 간단하게 추가할 수 있다. 

### 컴포넌트 스캔(component-scan) 설정

스프링 설정 파일에 애플리케이션에서 사용할 객체들을 `<bean>` 등록하지 않고 자동으로 생성하려면 `<context:component-scan>`이라는 엘리먼트를 정의해야 한다. 이 설정을 추가하면 스프링 컨테이너는 클래스 패스에 있는 클래스들을 스캔하여 @Component가 설정된 클래스들을 자동으로 객체 생성한다.

### @Component

`<context:component-scan>`를 설정했으면 이제 스프링 설정 파일에 클래스들을 일일이 `<bean>` 엘리먼트로 등록할 필요가 없다. @Component만 클래스 선언부 위에 설정하면 끝난다. 예를 들어, LgTV 클래스에 대한 `<bean>` 등록을 XML 설정과 어노테이션 설정으로 처리하면 다음과 같다.

## 의존성 주입 어노테이션

### 의존성 주입 어노테이션

스프링에서 의존성 주입을 지원하는 어노테이션으로는 @Autowired, @Inject, @Qualifier, @Resource가 있다.

| 어노테이션 | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| @Autowired | 주로 변수 위에 설정하여 해당 타입의 객체를 찾아서 자동으로 할당한다.<br />org.springframework.beans.factory.annotation.Autowired |
| @Qualifier | 특정 객체의 이름을 이용하여 의존성 주입할 때 사용한다.<br />org.springframework.beans.factory.annotation.Qualifier |
| @Inject    | @Autowired와 동일한 기능을 제공한다.<br />javax.annotation.Resource |
| @Resource  | @Autowired와 @Qualifier의 기능을 결합한 어노테이션이다.<br />javax.inject.Inject |

이 중에서 @Autowired와 @Qualifier는 스프링에서 제공하지만, 나머지 어노테이션은 스프링에서 제공하지 않는다.

### @Autowired

@Autowired은 생성자나 메소드, 멤버변수 위에 모두 사용할 수 있다. 어디에 사용하든 결과가 같아서 상관없지만, 대부분은 멤버변수 위에 선언하여 사용한다. 스프링 컨테이너는 멤버변수 위에 붙은 @Autowired를 확인하는 순간 해당 변수의 타입을 체그한다. 그리고 그 타입의 객체가 메모리에 존재하는지를 확인한 후에, 그 객체를 변수에 주입한다.

그런데 만약 @Autowired가 붙은 객체가 메모리에 없다면 컨테이너가 NoSuchBeanDefinitionException을 발생시킨다. 다음 메시지는 @Autowired 대상 객체가 메모리에 존재하지 않는다는 의미이다.

### @Qualifier

문제는 의존성 주입 대상이 되는 Speaker 타입의 객체가 두 개 이상일 때 발생한다. 만약 SonySpeaker와 AppleSpeaker 객체가 모두 메모리에 생성되어 있는 상황이라면 컨테이너는 어떤 객체를 할당할지 스스로 판단할 수 없어서 에러가 발생한다. 이런 상황을 테스트하기 위해서 AppleSpeaker 클래스에도 @Component를 선언한다.

### @Resource

앞에서 살펴본 @Autowired는 변수의 타입을 기준으로 객체를 검색하여 의존성 주입을 처리하지만, @Resource는 객체의 이름을 이용하여 의존성 주입을 처리한다. @Resource는 name 속성을 사용할 수 있어서, 스프링 컨테이너가 해당 이름으로 생성된 객체를 검색하여 의존성 주입을 처리한다.

### 어노테이션과 XML 설정 병행하여 사용하기

스프링으로 의존성 주입을 처리할 때, XML 설정과 어노테이션 설정은 장단점이 서로 상충한다. 앞에서 살펴본 대로 XML 방식은 자바 소스를 수정하지 않고 XML 파일의 설정만 변경하면 실행되는 Speaker를 교체할 수 있어서 유지보수가 편하다. 하지만 XML 설정에 대한 부담 역시 존재한다. 그리고 자바 소스에 의존관계와 관련된 어떤 메타데이터도 없으므로 XML 설정을 해석해야만 무슨 객체가 의존성 주입되는지를 확인할 수 있다.

반면에 어노테이션 기반 설정은 XML 설정에 대한 부담도 없고, 의존관계에 대한 정보가 자바 소스에 들어있어서 사용하기는 편하다. 하지만 의존성 주입할 객체의 이름이 자바 소스에 명시되어야 하므로 자바 소스를 수정하지 않고 Speaker를 교체할 수 없다는 문제가 생긴다. 이런 문제를 서로의 장점을 조합하는 것으로 해결할 수 있는데, 다음 실습으로 확인해본다.

우선 LgTV 클래스의 speaker 변수를 원래대로 @Autowired 어노테이션만 설정한다.

## 추가 어노테이션

다음 그림은 시스템의 전체 구조를 두 개의 레이어로 표현한 것이다. 먼저 프레젠테이션 레이어는 사용자와의 커뮤니케이션을 담당하고, 비즈니스 레이어는 사용자의 요청에 대한 비즈니스 로직 처리를 담당한다.

# 비즈니스 컴포넌트 1

지금까지 스프링 프레임워크의 개념과 문법을 정리하면서 TV 예제를 사용했다. 그러나 TV예제는 문법을 확인하기 위해서 사용한 샘플이며, 실제 비즈니스 컴포넌트와는 거리감이 있을 수 있다. 이번 시간에는 일반적으로 프로젝트에서 사용하는 구조로 비즈니스 컴포넌트를 구현한 후, 스프링의 Dependency Lookup과 Dependency Injection을 점검해보도록 한다.

## BoardService 컴포넌트 구조

프로젝트마다 조금씩은 다르겠지만 일반적으로 비즈니스 컴포넌트는 네 개의 자바 파일로 구성된다. 그리고 각 자바 파일을 작성하는 순서와 이름 규칙도 어느 정도는 정해져 있는 것이 일반적이다. 이번에는 게시판 관련 컴포넌트를 구현하면서 비즈니스 컴포넌트의 작성 순서와 이름 규칙 등도 살펴본다.

## Value Object 클래스 작성

VO(Value Object) 클래스는 레이어와 레이어 사이에서 관련된 데이터를 한꺼번에 주목받을 목적으로 사용하는 클래스이다. DTO(Data Transfer Object)라 하기도 하는데, 데이터 전달을 목적으로 사용하는 객체이므로 결국 같은 의미의 용어라고 생각하면 된다.

VO 클래스를 작성하려면 가장 먼저 데이터베이스에 생성되어 있는 테이블의 구조를 확인해야 한다.

## DAO 클래스 작성

DAO(Data Access Object) 클래스는 데이터베이스 연동을 담당하는 클래스이다. 따라서 DAO 클래스에는 CRUD 기능의 메소드가 구현되어야 하는데, 이때 데이터베이스(Oracle이던, MariaDB이던)에서 제공하는 JDBC 드라이버가 필요하다.

### 드라이버 내려받기

BoardWeb 프로젝트에 있는 pom.xml 파일을 열고 다음과 같이 추가한다. `<dependencies` 태그를 찾아서 바로 밑에 추가하면 된다.

### JDBC Utility 클래스

당분간 Mybatis 같은 프레임워크를 사용하기 전까지는 데이터베이스 연동 처리를 JDBC로 할 것이다. 따라서 모든 DAO 클래스에서 공통으로 사용할 JDBCUtil 클래스를 작성하여 Connection 획득과 해제 작업을 공통으로 처리하도록 한다.

### DAO 클래스 작성

앞에서 작성한 BoardVO 객체를 매개변수와 리턴타입으로 사용하면서 BOARD 테이블과 CRUD 기능을 처리할 BoardDAO 클래스를 다음과 같이 작성한다.

## Service 인터페이스 작성

DAO 클래스를 작성했으면 이제 DAO 클래스에서 Alt + Shift + T 단축키를 이용하여 BoardService 인터페이스를 작성한다. 이때 인터페이스가 만들어지는 동시에 BoardDAO 클래스에는 implements 코드가 자동으로 설정되는데, 이 implements 코드는 삭제해야 한다. 클래스 다이어그램을 확인해보면 알겠지만 BoardService 인터페이스는 BoardServiceImpl 클래스가 구현해야 하고, BoardDAO 클래스는 독립된 클래스로 구현되어야 한다. 

## Service 구현 클래스 작성

이제 마지막으로 BoardService 인터페이스를 구현한 BoardServiceImpl 클래스를 구현하면 비즈니스 컴포넌트는 마무리된다. BoardServiceImpl 클래스의 비즈니스 메소드를 구현할 때, 멤버변수로 선언된 BoardDAO를 이용하면 된다. 

## BoardService 컴포넌트 테스트

### 스프링 설정 파일 수정

작성된 BoardService 컴포넌트를 스프링 기반으로 테스트하려면 우선 스프링 설정 파일에 `<context:component-scan>` 설정을 수정한다.

### 클라이언트 작성 및 실행

이제 마지막으로 스프링 컨테이너를 구동하고 BoardService 컴포넌트를 사용하는 클라이언트 프로그램을 다으뫄 같이 작성하여 글 등록 기능과 글 목록 검색 기능을 테스트한다.

# 비즈니스 컴포넌트 실습 2

BoardService 컴포넌트를 만들었으면 이제 회원 정보를 관리하는 UserService 컴포넌트를 추가로 개발한다. BoardService와 동일한 절차로 개발하면 되므로 큰 문제는 없을 것이다. 하지만 이번에는 어노테이션을 사용하지 않고, Setter 인젝션으로 의존성 주입을 처리하고 나서 어노테이션으로 변경하는 과정을 거칠 것이다.

## UserService 컴포넌트 구조

먼저 UserService 컴포넌트에 대한 클래스 다이어그램이다. BoardService보다 심플하게 구성되어 있다.

## Value Object 클래스 작성

VO(Value Object) 클래스를 작성하기 위해서 USERS 테이블의 구조를 확인한다.

## DAO 클래스 작성

JDBCUtil 클래스를 이용하여 UserDAO 클래스의 메소드를 구현한다. 다만 UserDAO 클래스에는 회원 정보 하나를 검색하는 getUser() 메소드만 구현하도록 한다.

## Service 인터페이스 작성

UserDAO 클래스에서 이클립스의 Alt + Shift + T 단축키를 이용하여 간단하게 UserService 인터페이스를 작성한다. 이때 BoardService와 마찬가지로 인터페이스가 만들어지는 동시에 UserDAO 클래스에 implements 코드가 자동으로 추가되는데, 이 implements 코드 역시 삭제한다.

## Service 구현 클래스 작성

이제 마지막으로 UserService 인터페이스를 구현하는 UserServiceImpl 클래스를 만들면 비즈니스 컴포넌트는 마무리된다.

## UserService 컴포넌트 테스트

작성된 UserService 컴포넌트를 테스트하기 위해서 우선 스프링 설정 파일인 applicationContext.xml에 UserServiceImpl와 UserDAO 클래스를 각각 `<bean>` 등록한다. 그리고 UserServiceImpl 클래스에서 UserDAO 객체를 의존성 주입하기 위한 `<propertty >`설정을 추가하면 설정은 마무리된다.

## 어노테이션 적용

Setter 인젝션 설정으로 테스트한 UserService 컴포넌트를 어노테이션 설정으로 변경한다. 우선 스프링 설정 파일에 Setter 인젝션 관련 설정을 모두 주석 처리하거나 삭제한다.

# 스프링 AOP

비즈니스 컴포넌트 개발에서 가장 중요한 두 가지 원칙은 낮은 결합도와 높은 응집도를 유지하는 것이다. 스프링의 의존성 주입(Dependency Injection)을 이용하면 비즈니스 컴포넌트를 구성하는 객체들의 결합도를 떨어뜨릴 수 있어서 의존관계를 쉽게 변경할 수 있다. 스프링의 IoC가 결합도와 관련된 기능이라면, AOP(Aspect Oriented Programming)는 응집도와 관련된 기능이라 할 수 있다.

## AOP 이해하기

엔터프라이즈 애플리케이션의 메소드들은 대부분 다음과 같이 복잡한 코드들로 구성되어 있다. 이 중에서 핵심 비즈니스 로직은 몇 줄 안 되고, 주로 로깅이나 예외, 트랜잭션 처리 같은 부가적인 코드가 대부분이다. 이런 부가적인 코드들로 인해서 비즈니스 메소드의 복잡도는 증가하고 결국 개발자를 지치게 한다.

## AOP 시작하기

이번에는 스프링의 AOP를 이용해서 핵심 관심과 횡단 관심을 분리해본다. 이 실습이 마무리되면 BoardServiceImpl 소스와는 전혀 무관하게 LogAdvice나 Log4jAdvice 클래스의 메소드를 실행할 수 있게 된다.

### 비즈니스 클래스 수정

먼저 앞에서 작성했던 BoardServiceImpl 클래스는 원래의 상태로 되돌린다.

### AOP 라이브러리 추가

본격적으로 AOP를 적용하기 위해서 우선 BoardWeb 프로젝트에 있는 pom.xml 파일을 수정하여 AOP 관련 라이브러리를 추가한다. 

### 네임스페이스 추가 및 AOP 설정

AOP 설정을 추가하려면 AOP에서 제공하는 엘리먼트들을 사용해야 한다. 따라서 스프링 설정 파일(applicationContext.xml)에서 [Namespace] 탭을 클릭하고 aop 네임스페이스를 추가한다.

### 테스트 및 결과 확인

이제 BoardServiceClient 프로그램을 실행하여 insertBoard()와 getBoardList() 메소드가 호출될 때 LogAdvice 클래스의 printLog() 메소드가 실행되는지 확인하면 된다.

# AOP 용어 및 기본 설정

## AOP 용어 정리

AOP를 제대로 사용하려면 AOP와 관련된 용어들을 정확하게 이해해야 한다. 지금부터 AOP에서 사용하는 용어들을 하나씩 정리해보자.

### 조인포인트(Joinpoint)

조인포인트는 클라이언트가 호출하는 모든 비즈니스 메소드로서, BoardServiceImpl이나 UserServiceImpl 클래스의 모든 메소드를 조인포인트라고 생각하면 된다. 조인포인트를 다음에 설명할 '포인트컷 대상' 또는 '포인트컷 후보'라고도 하는데, 이는 조인포인트 중에서 포인트것이 선택되기 때문이다.

### 포인트컷(Pointcut)

클라이언트가 호출하는 모든 비즈니스 메소드가 조인포인트라면, 포인트컷은 필터링된 조인포인트를 의미한다. 예를 들어, 트랜잭션을 처리하는 공통 기능을 만들었다고 가정한다. 이 횡단 관심 기능은 등록, 수정, 삭제 기능의 비즈니스 메소드에 대해서는 당연히 동작해야 하지만, 검색 기능의 메소드에 대해서는 트랜잭션과 무관하므로 동작할 필요가 없다.

### 어드바이스(Advice)

어드바이스는 횡단 관심에 해당하는 공통 기능의 코드를 의미하며, 독립된 클래스의 메소드로 작성된다. 그리고 어드바이스로 구현된 메소드가 언제 동작할지 스프링 설정 파일을 통해서 지정할 수 있다.

예를 들어, 트랜잭션 관리 기능의 어드바이스 메소드가 있다고 가정하자. 이 어드바이스가 비즈니스 로직이 수행되기 전에 동작하는 것은 아무런 의미가 없다. 당연히 비즈니스 로직 수행 후에 트랜잭션을 커밋(commit) 또는 롤백(rollback) 처리하면 된다.

### 위빙(Weaving)

위빙은 포인트컷으로 지정한 핵심 관심 메소드가 호출될 때, 어드바이스에 해당하는 횡단 관심 메소드가 삽입되는 과정을 의미한다. 이 위빙을 통해서 비즈니스 메소드를 수정하지 않고도 횡단 관심에 해당하는 기능을 추가하거나 변경할 수 있다.

### 애스팩트(Aspect) 또는 어드바이저(Advisor)

Aspect Oriented Programming이라는 이름에서 알 수 있듯이 AOP의 핵심은 바로 애스팩트이다. 애스팩트는 포인트컷과 어드바이스의 결합으로서, 어떤 포인트컷 메소드에 대해서 어떤 어드바이스 메소드를 실행할지 결정한다. 이 애스팩트 설정에 따라 AOP의 동작 방식이 결정되므로 AOP 용어 중 가장 중요한 개념이라 할 수 있다.

다음은 우리가 지금까지 사용한 애스팩트 설정이며, 각 설정의 의미를 정확하게 해석할 수 있어야 한다.

### AOP 용어 종합

다음 그림은 지금까지 살펴본 AOP 용어들을 하나의 그림으로 표현한 것이다.

## AOP 엘리먼트

지금까지 AOP와 관련된 용어들을 살펴봤다면, 이제부터는 AOP와 관련된 다양한 설정을 살펴볼 것이다. 스프링은 AOP 관련 설정을 XML 방식과 어노테이션 방식으로 지원하는데, 우선 XML 설정을 먼저 확인하고 이후에 어노테이션 설정을 살펴보도록 한다.

### [aop:config] 엘리먼트

AOP 설정에서 `<aop:config>`는 루트 엘리먼트이다. 스프링 설정 파일 내에 `<aop:config>` 엘리먼트는 여러 번 사용할 수 있으며, `<aop:config>` 엘리먼트 하위에는 `<aop:pointcut>`, `<aop:aspect>` 엘리먼트가 위치할 수 있다. 다음 그림은 AOP 엘리먼트들의 포함 관계를 표현한 것이다.

### [aop:pointcut] 엘리먼트

`<aop:pointcut>` 엘리먼트는 포인트컷을 지정하기 위해 사용하며, `<aop:config>`의 자식이나 `<aop:aspect>`의 자식 엘리먼트로 사용할 수 있다. 그러나 `<aop:aspect>` 하위에 설정된 포인트컷은 해당 `<aop:aspect>`에서만 사용할 수 있다.

`<aop:pointcut>`은 여러 개 정의할 수 있으면, 유일한 아이디를 할당하여 애스팩트를 설정할 때 포인트컷을 참조하는 용도로 사용한다.

### [aop:aspect] 엘리먼트

애스팩트는 `<aop:aspect>` 엘리먼트로 설정하며, 핵심 관심에 해당하는 포인트컷 메소드와 횡단 관심에 해당하는 어드바이스 메소드를 결합하기 위해 사용한다. 에스팩트를 어떻게 설정하느냐에 따라서 위빙 결과가 달라지므로 AOP에서 가장 중요한 설정이라 할 수 있다.

### [aop:advisor] 엘리먼트

용어 정리에서 확인했듯이 `<aop:advisor>` 엘리먼트는 포인트컷과 어드바이스를 결합한다는 점에서 애스팩트와 같은 기능을 한다. 하지만 트랜잭션 설정 같은 몇몇 특수한 경우는 애스팩트가 아닌 어드바이저를 사용해야 한다. 간단한 예를 통해 애스팩트와 어드바이저를 사용하는 기준을 확인해보자.

AOP 설정에서 애스팩트를 사용하려면 어드바이스의 아이디와 메소드 이름을 알아야 한다. 다음 설정은 log라는 어드바이스 객체의 printLog() 어드바이스 메소드를 포인트컷과 결합하는 설정이다.

## 포인트컷 표현식

포인트컷을 이용하면 어드바이스 메소드가 적용될 비즈니스 메소드를 정확하게 필터링할 수 있는데, 이때 다양한 포인트컷 표현식을 사용할 수 있다. 포인트컷 표현식은 메소드처럼 생긴 execution 명시자를 이용하여, execution 명시자 안에 포인트컷 표현식을 기술한다. 전체적인 구조는 다음과 같다.

# 어드바이스 동작 시점

어드바이스는 각 조인포인트에 삽입되어 동작할 횡단 관심에 해당하는 공통 기능이며, 동작 시점은 각 AOP 기술마다 다르다. 스프링에서는 다섯 가지의 동작 시점을 제공한다.

| 동작 시점 | 설명                                                         |
| --------- | ------------------------------------------------------------ |
| Before    | 비즈니스 메소드 실행 전 동작                                 |
| After     | - After Returning : 비즈니스 메소드가 성공적으로 리턴되면 동작<br />- After Throwing : 비즈니스 메소드 실행 중 예외가 발생하면 동작(마치 try-catch 블록에서 catch 블록에 해당)<br />- After : 비즈니스 메소드가 실행된 후, 무조건 실행(try ~ catch ~ finally 블록에서 finally 블록에 해당) |
| Around    | Around는 메소드 호출 자체를 가로채 비즈니스 메소드 실행 전후에 처리할 로직을 삽입할 수 있음 |

## Before 어드바이스

Before 어드바이스는 포인트컷으로 지정된 메소드 호출 시, 메소드가 실행되기 전에 처리될 내용들을 기술하기 위해 사용된다. Before 어드바이스의 동작 시점을 그림으로 표현하면 다음과 같다.

## After Returning 어드바이스

After Returning 어드바이스는 포인트컷으로 지정된 메소드가 정상적으로 실행되고 나서, 메소드 수행 결과로 생성된 데이터를 리턴하는 시점에 동작한다. 따라서 비즈니스 메소드 수행 결과로 얻은 결과 데이터를 이용하여 사후 처리 로직을 추가할 때 사용한다. After Returning 어드바이스의 동작 시점을 그림으로 표현하면 다음과 같다.

## After Throwing 어드바이스

After Throwing 어드바이스는 포인트컷으로 지정한 메소드가 실행되다가 예외가 발생하는 시점에 동작한다. 따라서 예외 처리 어드바이스를 설정할 때 사용한다. After Throwing 어드바이스의 동작 시점을 그림으로 표현하면 다음과 같다.

## After 어드바이스

try-catch-finally 구문에서 finally 블록처럼 예외 발생 여부에 상관없이 무조건 수행되는 어드바이스를 등록할 때 After 어드바이스를 사용한다.

After 어드바이스의 동작 시점을 그림으로 표현하면 다음과 같다.

## Around 어드바이스

지금까지 비즈니스 메소드 실행 전이나 실행 후에 수행되는 어드바이스를 살펴봤다. 하지만 어떤 상황에서는 하나의 어드바이스가 비즈니스 메소드 실행 전과 후에 모두 동작하여 로직을 처리하는 경우도 있을 것이다. 이때 사용하는 어드바이스가 Around 어드바이스이다. Around 어드바이스의 동작 시점을 그림으로 표현하면 다음과 같다.

# JoinPoint와 바인드 변수

횡단 관심에 해당하는 어드바이스 메소드를 의미 있게 구현하려면 클라이언트가 호출한 비즈니스 메소드의 정보가 필요하다. 예를 들어, After Throwing 기능의 어드바이스 메소드를 구현한다고 가정한다. 이때, 예외가 발생한 비즈니스 메소드 이름이 무엇인지, 그 메소드가 속한 클래스와 패키지 정보는 무엇인지 알아야 정확한 예외 처리 로직을 구현할 수 있다. 스프링에서는 이런 다양한 정보들을 이용할 수 있도록 JoinPoint 인터페이스를 제공한다.

## JoinPoint 메소드

다음은 JoinPoint에서 제공하는 유용한 메소드들이다.

| 메소드                   | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| Signature getSignature() | 클라이언트가 호출한 메소드의 시그니처(리턴타입, 이름, 매개변수) 정보가 저장된 Signature 객체 리턴 |
| Object getTarget()       | 클라이언트가 호출한 비즈니스 메소드를 포함하는 비즈니스 객체 리턴 |
| Object[] getArgs()       | 클라이언트가 메소드를 호출할 때 넘겨준 인자 목록을 Object 배열로 리턴 |

## Before 어드바이스

Before 어드바이스는 비즈니스 메소드가 실행되기 전에 동작할 로직을 구현한다. 따라서 호출된 메소드 시그니처만 알 수 있으면 다양한 사전 처리 로직을 구현할 수 있다. 이때 Before 어드바이스 메소드의 매개변수로 JoinPoint를 선언한다.

클라이언트가 비즈니스 메소드를 호출할 때, 인자로 넘겨준 값들을 JoinPoint를 이용하여 출력하도록 BeforeAdvice 클래스를 수정한다.

## After Returning 어드바이스

After Returning은 비즈니스 메소드가 수행되고 나서, 결과 데이터를 리턴할 때 동작하는 어드바이스이다. 따라서 어떤 메소드가 어떤 값을 리턴했는지를 알아야 사후 처리 기능을 다양하게 구현할 수 있다. 기존에 작성했던 AfterReturningAdvice를 비즈니스 메소드가 리턴한 값을 이용하여 동작하도록 수정한다.

## After Throwing 어드바이스

After Throwing은 비즈니스 메소드가 수행되다가 예외가 발생할 때 동작하는 어드바이스이다. 따라서 어떤 메소드에서 어떤 예외가 발생했는지를 알아야 한다. 그래야 발생한 예외의 종류에 따라 정확한 예외 처리를 구현할 수 있을 것이다.

기존에 작성했던 AfterThrowingAdvice를 수정하여 예외가 발생한 메소드 이름과 발생한 예외 객체의 메시지를 출력하도록 수정한다.

## Around 어드바이스

Around 어드바이스는 다른 어드바이스와는 다르게 반드시 ProceedingJoinPoint 객체를 매개변수로 받아야 한다. ProceedingJoinPoint 객체는 비즈니스 메소드를 호출하는 proceed() 메소드를 가지고 있으며 JoinPoint를 상속했다.

# 어노테이션 기반 AOP

스프링 IoC를 학습하면서 XML 기반 설정과 어노테이션 기반 설정을 모두 사용했었다. 그리고 XML과 어노테이션 설정을 적절히 혼합하여 사용하면 XML 설정을 최소화하면서 객체들을 효율적으로 관리할 수 있었다. 스프링 AOP도 IoC와 마찬가지로 어노테이션 설정을 지원한다.

## 어노테이션 기반 AOP 설정

### 어노테이션 사용을 위한 스프링 설정

이번 시간에는 AOP 관련 어노테이션 종류와 기능에 대해서 살펴볼 것이다. AOP를 어노테이션으로 설정하려면 가장 먼저 스프링 설정 파일에 `<aop:aspectj-autoproxy>` 엘리먼트를 선언해야 한다.

### 포인트컷 설정

XML 설정에서 포인트컷을 선언할 때는 `<aop:pointcut>` 엘리먼트를 사용했다. 그리고 선언된 여러 포인트컷을 식별하기 위한 유일한 아이디를 지정했으며, 이후에 애스팩트 설정에서 특정 포인트컷을 참조할 수 있었다.

### 어드바이스 설정

어드바이스 클래스에는 횡단 관심에 해당하는 어드바이스 메소드가 구현되어 있다. 이 어드바이스 메소드가 언제 동작할지 결정하여 관련된 어노테이션을 메소드 위에 설정하면 된다. 어드바이스의 동작 시점은 XML 설정과 마찬가지로 다섯 가지가 제공된다.

이때 반드시 어드바이스 메소드가 결합될 포인트컷을 참조해야 한다. 포인트컷을 참조하는 방법은 어드바이스 어노테이션 뒤에 괄호를 추가하고 포인트컷 참조 메소드를 지정하면 된다.

### 애스팩트 설정

AOP 설정에서 가장 중요한 애스팩트는 @Aspect를 이용하여 설정한다. 애스팩트는 용어 정리 시간에 살펴봤듯이 포인트컷과 어드바이스의 결합이다. 따라서 @Aspect가 설정된 애스팩트 객체에는 반드시 포인트컷과 어드바이스를 결합하는 설정이 있어야 한다.

## 어드바이스 동작 시점

지금부터는 이전에 XML 기반으로 설정했던 각 어드바이스들을 어노테이션으로 변경해보도록 한다.

### Before 어드바이스

Before 어드바이스는 비즈니스 메소드가 실행되기 전에 공통으로 처리할 작업을 위해 사용한다. 앞에서 작성한 BeforeAdvice 클래스에 관련된 어노테이션을 추가한다.

### After Returning 어드바이스

After Returning 어드바이스는 비즈니스 메소드가 리턴한 결과 데이터를 다른 용도로 처리할 때 사용한다. 앞에서 작성한 AfterReturningAdvice 클래스에 관련된 어노테이션을 추가한다.

### After Throwing 어드바이스

After Throwing 어드바이스는 비즈니스 메소드 실행 도중에 예외가 발생했을 때, 공통적인 예외 처리 로직을 제공할 목적으로 사용하는 어드바이스이다. 앞에서 작성한 AfterThrowingAdvice 클래스에 관련된 어노테이션을 추가한다.

### After 어드바이스

After 어드바이스는 예외 발생 여부에 상관없이 무조건 수행되는 어드바이스로서 @After 어노테이션을 사용하여 설정한다. 이전에 작성했던 AfterAdvice 클래스를 다음과 같이 수정한다.

### Around 어드바이스 설정

Around 어드바이스는 하나의 어드바이스로 사전, 사후 처리를 모두 해결하고자 할 때 사용하며, @Around 어노테이션을 사용하여 설정한다.

### 외부 Pointcut 참조하기

XML 설정으로 포인트컷을 관리했을 때는 스프링 설정 파일에 포인트컷을 여러 개 등록했다. 그리고 애스팩트를 설정할 때 pointcut-ref 속성으로 특정 포인트컷을 참조할 수 있었기 때문에 포인트컷을 재사용할 수 있었다.

# 스프링 JDBC

## 스프링 JDBC 개념

JDBC는 가장 오랫동안 자바 개발자들이 사용한 DB 연동 기술이다. JDBC를 이용하여 DB 연동 프로그램을 개발하면 데이터베이스에 비종속적인 DB 연동 로직을 구현할 수 있다. 그런데 JDBC 프로그램은 이용하려면 개발자가 작성해야 할 코드가 너무 많다.

기존 UserDAO 클래스의 구성을 보자. 사용자가 입력한 아이디와 비밀번호와 매칭되는 회원 정보 하나를 조회하기 위해서 이렇게 많은 자바 코드를 사용해야 한다.

## JdbcTemplate 클래스

JdbcTemplate은 GoF 디자인 패턴 중 템플릿 메소드 패턴이 적용된 클래스이다. 템플릿 메소드 패턴은 복잡하고 반복되는 알고리즘을 캡슐화해서 재사용하는 패턴으로 정의할 수 있다. 템플릿 메소드 패턴을 이용하면 반복해서 사용되는 알고리즘을 템플릿 메소드로 캡슐화할 수 있어서 JDBC처럼 코딩 순서가 정형화된 기술에서 유용하게 사용할 수 있다. 따라서 반복되는 DB 연동 로직은 JdbcTemplate 클래스의 템플릿 메소드가 제공하고, 개발자는 달라지는 SQL 구문과 설정값만 신경 쓰면 된다.

## 스프링 JDBC 설정

### 라이브러리 추가

스프링 JDBC를 이용하려면 BoardWeb 프로젝트에 있는 pom.xml 파일에 DBCP 관련 `<dependency>` 설정을 추가해야 한다.

### DataSource 설정

JdbcTemplate 클래스가 JDBC API를 이용하여 DB 연동을 처리하려면 반드시 데이터베이스로부터 커넥션을 얻어야 한다. 따라서 JdbcTemplate 객체가 사용할 DataSource를 `<bean>` 등록하여 스프링 컨테이너가 생성하도록 해야 한다. 사실 DataSource 설정은 스프링 JDBC만을 위한 설정은 아니다. 이후에 테스트할 트랜잭션 처리나 Mybatis 연동, JPA 연동에서도 DataSource가 사용되므로 매우 중요한 설정이라 할 수 있다.

### 프로퍼티 파일을 활용한 DataSource 설정

PropperttyPlaceholderConfigurer를 이용하면 외부의 프로퍼티 파일을 참조하여 DataSource를 설정할 수 있다. 실습을 위해 src/main/resource 소스 폴더에 config 폴더를 생성하고 config 폴더에 database.properties 파일을 작성한다.

## JdbcTemplate 메소드

스프링 JDBC를 위한 기본 설정이 마무리됐으면 이제 JdbcTemplate 객체를 이용하여 DB 연동을 간단하게 처리할 수 있다.

### update() 메소드

INSERT, UPDATE, DELETE 구문을 처리하려면 JdbcTamplate 클래스의 update() 메소드를 사용한다. update() 메소드의 사용법은 "?"에 값을 설정하는 방식에 따라 크게 두 가지 형태가 있다. 

### queryForInt() 메소드

SELECT 구문으로 검색된 정수값을 리턴받으려면 queryForInt() 메소드를 사용한다. 매개변수의 의미는 앞에서 살펴본 update() 메소드와 같다.

### queryForObject() 메소드

queryForObject() 메소드는 SELECT 구문의 실행 결과를 특정 자바 객체(Value Object)로 매핑하여 리턴받을 때 사용한다. queryForObject() 메소드는 검색 결과가 없거나 검색 결과가 두 개 이상이면 예외(IncorrectResultSizeDataAccessException)를 발생시킨다.

그리고 중요한 것은 검색 결과를 자바 객체(Value Object)로 매핑할 RowMapper 객체를 반드시 지정해야 한다.

### query() 메소드

queryForObject()가 SELECT 문으로 객체 하나를 검색할 때 사용하는 메소드라면, query() 메소드는 SELECT 문의 실행 결과가 목록일 때 사용한다. 기본 사용법은 queryForObject() 메소드와 같다. 따라서 query() 메소드에서도 검색 결과를 VO 객체에 매핑하려면 RowMapper 객체를 사용한다.

## DAO 클래스 구현

스프링 JDBC를 이용하기 위한 모든 설정이 마무리됐으면, 이제 JdbcTemplate 객체를 이용하여 DAO 클래스만 구현하면 된다. 그런데 DAO 클래스에서 JdbcTemplate 객체를 얻는 방법은 두 가지이다.

### 첫 번째 방법 : JdbcDaoSupport 클래스 상속

첫 번째 방법은 JdbcDaoSupport 클래스를 상속하는 방법이다.

### 두 번째 방법 : JdbcTemplate 클래스 [bean] 등록, 의존성 주입

DAO 클래스에서 JdbcTemplate 객체를 얻는 두 번째 방법은 JdbcTemplate 클래스를 `<bean>` 등록하고, 의존성 주입으로 처리하는 것이다. 일반적으로 이 방법을 사용한다. 먼저 스프링 설정 파일에 JdbcTemplate 클래스를 `<bean>` 등록한다.

# 트랜잭션 처리

스프링과 비교되는 EJB는 모든 비즈니스 메소드에 대한 트랜잭션 관리를 EJB 컨테이너가 자동으로 처리해준다. 스프링에서도 EJB와 마찬가지로 트랜잭션 처리를 컨테이너가 자동으로 처리하도록 설정할 수 있는데, 이를 선언적 트랜잭션 처리라고 한다.

스프링의 트랜잭션 설정에서는 앞에서 학습한 AOP가 사용된다. 그런데 XML 기반의 AOP 설정만 사용할 수 있고, 어노테이션은 사용할 수 없다. 그리고 애스팩트를 설정하는 것도 `<aop:aspect>` 엘리먼트를 사용하지 못하고 `<aop:advisor>` 엘리먼트를 사용해야 한다. 이는 트랜잭션 관리에 사용되는 어드바이스가 독특하기 때문이다.

## 트랜잭션 네임스페이스 등록

스프링에서는 트랜잭션 관련 설정을 앞에서 살펴본 AOP로 처리한다. 그리고 추가로 트랜잭션을 제어하는 어드바이스를 설정하기 위해 스프링 설정 파일에 트랜잭션 관련 네임스페이스도 추가해야 한다. [Namespaces] 탭을 선택하고 tx 네임스페이스를 추가한다.

## 트랜잭션 관리자 등록

트랜잭션 관련 설정에서 가장 먼저 등록하는 것은 트랜잭션 관리자 클래스이다. 스프링은 다양한 트랜잭션 관리자를 지원하는데, 어떤 기술을 이용하여 데이터베이스 연동을 처리했느냐에 따라 트랜잭션 관리자가 달라진다. 그리고 모든 트랜잭션 관리자는 PlatformTransactionManager 인터페이스를 구현한 클래스들이다.

## 트랜잭션 어드바이스 설정

트랜잭션 관리 기능의 어드바이스는 `<tx:advice>` 엘리먼트를 사용하여 설정한다. 앞에서 트랜잭션 설정을 위한 tx 네임스페이스를 추가했으므로 다음과 같이 스프링 설정 파일에 `<tx:advice>` 엘리먼트를 이용하여 트랜잭션 관리 어드바이스를 설정한다.

## AOP 설정을 통한 트랜잭션 적용

트랜잭션 관리 어드바이스까지 설정했으면 비즈니스 메소드 실행 후에 트랜잭션 관리 어드바이스가 동작하도록 AOP 설정만 추가하면 된다. 이때 `<aop:aspect>` 엘리먼트를 사용하지 않고 `<aop:advisor>` 엘리먼트를 사용한다는 점이 기존 AOP 설정과 다르다. 우리는 앞에서 포인트컷과 어드바이스를 결합할 때 `<aop:aspect>` 엘리먼트를 사용했다.

## 트랜잭션 설정 테스트

지금까지 작성한 트랜잭션 관련 설정이 실제 트랜잭션 관리를 지원하는지 간단하게 테스트한다. 우선 BoardServiceClient에서 명시적으로 100번 글을 등록하도록 한다.

# Model 1 아키텍처로 게시판 개발

## Model 1 아키텍처 구조

90년대 말부터 2000년대 초까지 자바 기반의 웹 애플리케이션 개발에 사용됐던 아키텍처는 Model 1이다. Model 1 아키텍처는 JSP와 JavaBeans만 사용하여 웹을 개발하는 것으로 아래 그림과 같은 구조다.

## 로그인 기능 구현

## 글 목록 검색 기능 구현

## 글 상세 기능 구현

## 글 수정 기능 구현

## 글 삭제 기능 구현

## 로그아웃 기능 구현

# Model 2 아키텍처로 게시판 개발

## Model 2 아키텍처 구조

우리는 이전 시간에 Model 1 아키텍처로 게시판 프로그램을 개발했다. 물론 게시판처럼 작고 단순한 시스템을 개발하거나 개발 인력이 충분하지 않을 때는 구조가 단순한 Model 1 아키텍처를 사용하기도 한다. 하지만 시스템의 규모가 크고 기능이 복잡한 엔터프라이즈 시스템을 개발한다면 Model 1 아키텍처는 적합하지 않다.

## Controller 구현하기

### 서블릿 생성 및 등록

### Controller 서블릿 구현

## 로그인 기능 구현하기

## 글 목록 검색 기능 구현하기

## 글 상세 보기 기능 구현하기

## 글 등록 기능 구현하기

## 글 수정 기능 구현하기

## 글 삭제 기능 구현하기

## 로그아웃 기능 구현하기

# 프레임워크 개발

## MVC 프레임워크 구조

지금까지 개발한 게시판 프로그램은 MVC 아키텍처를 적용하긴 했지만, DispatcherServlet 클래스 하나로 Controller 기능을 구현했다. 하지만 이렇게 하나의 서블릿으로 Controller를 구현하면 클라이언트의 모든 요청을 하나의 서블릿이 처리하게 된다. 따라서 수많은 분기 처리 로직을 가질 수밖에 없고, 이는 오히려 개발과 유지보수를 어렵게 만든다.

## MVC 프레임워크 구현

## MVC 프레임워크 적용

## EL/JSTL 이용한 JSP 화면 처리

# Spring MVC 구조

## Spring MVC 수행 흐름

Struts를 비롯한 대부분의 MVC 프레임워크는 비슷한 구조를 가졌다. 따라서 하나의 프레임워크만 잘 이해하면 다른 프레임워크도 쉽게 이해할 수 있다. 앞에서 Spring MVC와 구조가 같은 Controller를 만들어 게시판 프로그램에 적용했다. 따라서 지금부터 살펴볼 Spring MVC 구조가 전혀 새롭지는 않을 것이다.

## DispatcherServlet 등록 및 스프링 컨테이너 구동

### DispatcherServlet 등록

### 스프링 컨테이너 구동

### 스프링 설정 파일 등록

## 스프링 설정 파일 변경

## 인코딩 설정

# Spring MVC 적용

## Spring MVC 적용 준비

## 로그인 기능 구현하기

## 글 목록 검색 기능 구현하기

## 글 상세 조회 기능 구현하기

## 글 등록 기능 구현하기

## 글 수정 기능 구현하기

## 글 삭제 기능 구현하기

## 로그아웃 기능 구현하기

## ViewResolver 활용하기

# 어노테이션 기반 MVC 개발

스프링은 어노테이션 기반 설정을 제공함으로써 과도한 XML 설정으로 인한 문제를 해결한다. Spring MVC도 스프링 설정 파일에 HandlerMapping, Controller, ViewResolver 같은 여러 클래스를 등록해야 하므로 어노테이션 설정을 최대한 활용하여 XML 설정을 최소화할 필요가 있다.

## 어노테이션 관련 설정

## @Controller 사용하기

## @RequestMapping 사용하기

## 클라이언트 요청 처리

# 어노테이션으로 게시판 프로그램 구현하기

## 글 등록 기능 구현하기

## 글 목록 검색 구현하기

## 글 상세 보기 구현하기

## 글 수정 기능 구현하기

## 글 삭제 기능 구현하기

## 로그인 기능 구현하기

## 로그아웃 기능 구현하기

## 컨트롤러 통합하기

## 요청 방식에 따른 처리

### method 속성

### JSP에서 Command 객체 사용

### @ModelAttribute 사용

## Servlet API 사용

## Controller의 리턴타입

## 기타 어노테이션

### @RequestParam 사용하기

### @ModelAttribute 사용하기

### @SessionAttributes 사용하기

# 프레젠테이션 레이어와 비즈니스 레이어 통합

## 비즈니스 컴포넌트 사용

## 비즈니스 컴포넌트 로딩

### 2-Layered 아키텍처

### ContextLoaderListner 등록

### 스프링 컨테이너의 관계

# 검색 기능 추가 구현

## 검색 정보 추출

## Controller 구현

## DAO 클래스 수정

# 파일 업로드

## 파일 업로드 처리

## 예외 처리

### 어노테이션 기반의 예외 처리

### XML 기반의 예외 처리

# 다국어 처리

## 메시지 파일 작성하기

### 영어 메시지 파일 작성

### 한글 메시지 파일 작성

## MessageSource 등록

## LocalResolver 등록

## Locale 변경하기

## JSP 파일 작성

# 데이터 변환

## JSON으로 변환하기

### Jackson2 라이브러리 내려받기

### HttpMessageConvertor 등록

### 링크 추가 및 Controller 수정

### 실행 결과 확인

## XML로 변환하기

### JAXB 2 설정 추가

### Controller 수정

### 실행 결과 확인

# Mybatis 프레임워크 시작하기

## Mybatis 프레임워크 특징

## Java ORM Plugin 설치

## 프로젝트 생성

## VO(Value Object) 클래스 작성

## SQL Mapper XML 파일 작성

## Mybatis 환경설정 파일

## SqlSession 객체 생성하기

## DAO 클래스 작성

## 테스트 클라이언트 작성 및 실행

# Mapper XML 파일 설정

## SQL Mapper XML 기본 설정

### Mybatis 구조

### Mapper XML 파일 구조

### [select] 엘리먼트

### [insert] 엘리먼트

### [update] 엘리먼트

### [delete] 엘리먼트

## SQL Mapper XML 추가 설정

### resultMap 속성 사용

### CDATA Section 사용

### SQL 대문자로 설정

## Mybatis JAVA API

### SqlSessionFactoryBuilder 클래스

### SqlSessionFactory 클래스

### 유틸리티 클래스 작성

### SqlSession 객체

# 스프링과 MyBatis 연동

## 라이브러리 내려받기

## Mybatis 설정 파일 복사 및 수정

## 스프링 연동 설정

## DAO 클래스 구현 - 방법1

## DAO 클래스 구현 - 방법2

## MyBatis 연동 테스트

## Dynamic SQL으로 검색 처리

# JPA 개념

## JPA의 특징

## JPA 프로젝트 생성

## JPA 라이브러리 내려받기

## JPA 시작하기

### 엔티티 클래스 매핑

### persistence.xml 파일 작성

### 클라이언트 프로그램 작성

# JPA 환경설정

## 영속성 유닛(Persistence Unit) 설정

### 영속성 유닛 이름 지정

### 엔티티 클래스 등록

### 영속성 유닛 프로퍼티 설정

### Dialect 클래스 설정

### JPA 구현체 관련 속성 설정

## 엔티티 클래스 기본 매핑

### @Entity, @Id

### @Table

### @Column

### @GeneratedValue

### @Transient

### @Temporal

## JPA API

### JPA API 구조

### JPA API 사용

# 스프링과 JPA 연동

## 스프링과 JPA 연동 기초

## 엔티티 매핑 설정

## 스프링과 JPA 연동 설정

## 트랜잭션 설정 수정

## DAO 클래스 구현

## BoardServicelmpl 클래스 수정 및 테스트

